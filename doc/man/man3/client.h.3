.TH "src/client.h" 3 "Quarta, 25 de Janeiro de 2012" "servw" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/client.h \- 
.PP
Definicao de procedimentos relacionados a servir clientes'\&.  

.SH SYNOPSIS
.br
.PP
.SS "Estruturas de Dados"

.in +1c
.ti -1c
.RI "struct \fBc_handler_list\fP"
.br
.ti -1c
.RI "struct \fBclienthandler_t\fP"
.br
.RI "\fIO responsavel por fornecer o servico ao cliente'\&. \fP"
.in -1c
.SS "Definições e Macros"

.in +1c
.ti -1c
.RI "#define \fBBUFFER_SIZE\fP   256"
.br
.in -1c
.SS "Enumerações"

.in +1c
.ti -1c
.RI "enum \fBstates\fP { \fBFINISHED\fP, \fBMSG_RECEIVING\fP, \fBFILE_PROCESSING\fP, \fBHEADER_SENDING\fP, \fBERROR_HEADER_SENDING\fP, \fBFILE_SENDING\fP, \fBERROR_SENDING\fP, \fBMSG_RECEIVED\fP, \fBHEADER_SENT\fP, \fBERROR_HEADER_SENT\fP, \fBFILE_SENT\fP, \fBERROR_SENT\fP }"
.br
.RI "\fITodos os estados possiveis do \fBclienthandler_t\fP'\&. \fP"
.in -1c
.SS "Funções"

.in +1c
.ti -1c
.RI "int \fBc_handler_list_init\fP (struct \fBc_handler_list\fP *l, int max_clients)"
.br
.RI "\fIFlag que indica se precisa pegar um pedaco do arquivo'\&. \fP"
.ti -1c
.RI "int \fBc_handler_init\fP (struct c_handler *h, int sck, char *rootdir)"
.br
.RI "\fIInicializa as variaveis internas de 'h', como o cliente 'sck' e o diretorio root 'rootdir''\&. \fP"
.ti -1c
.RI "int \fBc_handler_add\fP (struct c_handler *h, struct \fBc_handler_list\fP *l)"
.br
.RI "\fIAdiciona 'h' a lista 'l''\&. \fP"
.ti -1c
.RI "int \fBc_handler_remove\fP (struct c_handler *h, struct \fBc_handler_list\fP *l)"
.br
.RI "\fIRemove 'h' de 'l''\&. \fP"
.ti -1c
.RI "void \fBc_handler_exit\fP (struct c_handler *h)"
.br
.RI "\fILibera a memoria alocada para 'h''\&. \fP"
.ti -1c
.RI "int \fBreceive_message\fP (struct \fBclienthandler_t\fP *h)"
.br
.RI "\fIRecebe a mensagem atraves de recv() de uma maneira nao-bloqueante'\&. \fP"
.ti -1c
.RI "int \fBhandler_init\fP (struct \fBclienthandler_t\fP *h, int sck, char *rootdir)"
.br
.RI "\fIInicializa o \fBclienthandler_t\fP 'h' e associa seus servicos ao cliente representado por 'clientsckt''\&. \fP"
.ti -1c
.RI "int \fBfile_check\fP (struct \fBclienthandler_t\fP *h, char *rootdir, int rootdirsize)"
.br
.RI "\fICheca se o arquivo descrito dentro de 'h' existe ou nao e atribui a 'h' a mensagem de erro correspondente'\&. \fP"
.ti -1c
.RI "int \fBstart_sending_msg\fP (struct \fBclienthandler_t\fP *h)"
.br
.ti -1c
.RI "int \fBkeep_sending_msg\fP (struct \fBclienthandler_t\fP *h)"
.br
.RI "\fIContinua enviando para h->client a mensagem apontada por h->output atraves de sockets nao-bloqueantes'\&. \fP"
.ti -1c
.RI "int \fBstart_sending_file\fP (struct \fBclienthandler_t\fP *h)"
.br
.RI "\fIAbre o arquivo em 'h' para ser enviado'\&. \fP"
.ti -1c
.RI "int \fBstop_sending_file\fP (struct \fBclienthandler_t\fP *h)"
.br
.RI "\fIFecha o arquivo aberto para o 'h''\&. \fP"
.ti -1c
.RI "int \fBget_file_chunk\fP (struct \fBclienthandler_t\fP *h)"
.br
.RI "\fIPega um pedaco do arquivo e guarda no buffer dentro de 'h''\&. \fP"
.ti -1c
.RI "void \fBbuild_error_html\fP (struct \fBclienthandler_t\fP *h)"
.br
.RI "\fIConstroi e armazena em 'h->fileerror' uma pagina HTML contendo o erro ocorrido'\&. \fP"
.ti -1c
.RI "int \fBparse_request\fP (struct \fBclienthandler_t\fP *h)"
.br
.RI "\fISepara as partes uteis da request HTTP enviada pelo usuario'\&. \fP"
.ti -1c
.RI "int \fBbuild_header\fP (struct \fBclienthandler_t\fP *h)"
.br
.RI "\fIConstroi e atribui o header HTTP ao 'buf' (respeitando 'bufsize')'\&. \fP"
.in -1c
.SS "Variáveis"

.in +1c
.ti -1c
.RI "struct \fBc_handler_list\fP * \fBnext\fP"
.br
.RI "\fIProximo handler na lista'\&. \fP"
.ti -1c
.RI "int \fBclient\fP"
.br
.RI "\fISocket do cliente servido'\&. \fP"
.ti -1c
.RI "int \fBstate\fP"
.br
.RI "\fIEstado em que se encontra o handler'\&. \fP"
.ti -1c
.RI "char \fBrequest\fP [BUFFER_SIZE *3]"
.br
.RI "\fIToda a request HTTP solicitada pelo cliente'\&. \fP"
.ti -1c
.RI "int \fBrequest_size\fP"
.br
.RI "\fITamanho de caracteres que 'request' suporta'\&. \fP"
.ti -1c
.RI "char \fBfilepath\fP [BUFFER_SIZE]"
.br
.RI "\fILocalizacao do arquivo que o cliente solicitou'\&. \fP"
.ti -1c
.RI "int \fBfilestatus\fP"
.br
.RI "\fIIndica se o arquivo existe ou qual erro esta associado a ele'\&. \fP"
.ti -1c
.RI "char \fBfilestatusmsg\fP [BUFFER_SIZE]"
.br
.RI "\fIMensagem equivalente ao status do arquivo'\&. \fP"
.ti -1c
.RI "FILE * \fBfilep\fP"
.br
.RI "\fIArquivo que o cliente pede'\&. \fP"
.ti -1c
.RI "int \fBfilesize\fP"
.br
.RI "\fITamanho do arquivo solicitado'\&. \fP"
.ti -1c
.RI "int \fBfilesentsize\fP"
.br
.RI "\fITamanho que ja foi enviado do arquivo como um todo'\&. \fP"
.ti -1c
.RI "time_t \fBfilelastm\fP"
.br
.RI "\fIData de ultima modificacao do arquivo'\&. \fP"
.ti -1c
.RI "char \fBfilebuff\fP [BUFFER_SIZE]"
.br
.RI "\fIBuffer onde serao guardadas partes temporarias do arquivo'\&. \fP"
.ti -1c
.RI "char \fBanswer\fP [BUFFER_SIZE]"
.br
.RI "\fIHeader a ser enviado como resposta ao cliente, antes do arquivo'\&. \fP"
.ti -1c
.RI "int \fBanswer_size\fP"
.br
.RI "\fIO tamanho total do header'\&. \fP"
.ti -1c
.RI "int \fBsize_left\fP"
.br
.RI "\fIQuanto do arquivo (caso exista) ainda precisa ser enviado ao cliente'\&. \fP"
.ti -1c
.RI "int \fBsize_sent\fP"
.br
.RI "\fIQuanto do arquivo (caso exista) ja foi enviado ao cliente'\&. \fP"
.ti -1c
.RI "char \fBfileerror\fP [BUFFER_SIZE]"
.br
.ti -1c
.RI "int \fBfileerrorsize\fP"
.br
.RI "\fISe houver algum erro relacionado ao arquivo, sua mensagem estara aqui (no formato de pagina HTML) para ser enviada ao cliente'\&. \fP"
.ti -1c
.RI "char * \fBoutput\fP"
.br
.RI "\fIPonteiro que vai indicar o que vai ser enviado - o erro ou o header'\&. \fP"
.ti -1c
.RI "int \fBneed_file_chunk\fP"
.br
.in -1c
.SH "Descrição Detalhada"
.PP 
Definicao de procedimentos relacionados a servir clientes'\&. 


.SH "Funções"
.PP 
.SS "int build_header (struct \fBclienthandler_t\fP *h)"
.PP
Constroi e atribui o header HTTP ao 'buf' (respeitando 'bufsize')'\&. A mensagem e construida de acordo com os parametros'\&. 
.PP
\fBFuturas Atividades\fP
.RS 4
Remover valores arbitrarios dos buffers'\&. 
.RE
.PP
\fBRetorna:\fP
.RS 4
O numero de caracteres efetivamente atribuidos a 'buf''\&. 
.RE
.PP

.SS "int c_handler_add (struct c_handler *h, struct \fBc_handler_list\fP *l)"
.PP
Adiciona 'h' a lista 'l''\&. \fBRetorna:\fP
.RS 4
0 em sucesso, -1 em caso de erro - varios casos inclusos'\&. 
.RE
.PP

.SS "void c_handler_exit (struct c_handler *h)"
.PP
Libera a memoria alocada para 'h''\&. \fBObservação:\fP
.RS 4
O valor de 'h' se torna NULL'\&. 
.RE
.PP

.SS "int c_handler_init (struct c_handler *h, intsck, char *rootdir)"
.PP
Inicializa as variaveis internas de 'h', como o cliente 'sck' e o diretorio root 'rootdir''\&. \fBRetorna:\fP
.RS 4
0 em sucesso, -1 caso 'h' seja NULL ou malloc() falhe'\&. 
.RE
.PP

.SS "int c_handler_list_init (struct \fBc_handler_list\fP *l, intmax_clients)"
.PP
Flag que indica se precisa pegar um pedaco do arquivo'\&. Inicializa as variaveis internas de 'l', como o numero maximo de clientes suportados simultaneamente, 'max_clients''\&.
.PP
\fBRetorna:\fP
.RS 4
0 em sucesso, -1 caso 'l' seja NULL'\&. 
.RE
.PP

.SS "int c_handler_remove (struct c_handler *h, struct \fBc_handler_list\fP *l)"
.PP
Remove 'h' de 'l''\&. \fBObservação:\fP
.RS 4
Nao desaloca a memoria'\&. Para isso, veja 
.RE
.PP
\fBVeja também:\fP
.RS 4
\fBc_handler_exit()\fP
.RE
.PP
\fBAviso:\fP
.RS 4
Caso l->begin seja NULL ou l->end seja NULL ou l->current seja 0, essa funcao nao continua'\&. Entao, se algum desses for verdade mas os outros nao sejam, nunca poderemos remover - isso e um sinal para bug'\&. tl;dr Se a lista estiver corrompida, essa funcao nao funciona'\&.
.RE
.PP
\fBRetorna:\fP
.RS 4
0 em sucesso, -1 em caso de erro - varios casos inclusos'\&. 
.RE
.PP

.SS "int file_check (struct \fBclienthandler_t\fP *h, char *rootdir, introotdirsize)"
.PP
Checa se o arquivo descrito dentro de 'h' existe ou nao e atribui a 'h' a mensagem de erro correspondente'\&. Primeiro eu uso realpath() pra expandir todos os symbolic links do path recebido pelo cliente'\&. Se o arquivo nao existir, independentemente se ele esteja fora do diretorio permitido como root, ele vai avisar que nao existe'\&. Se o arquivo existir, mas estiver fora do diretorio permitido como root, ele vai avisar que esta fora do range'\&. 
.br
 tl;dr E possivel um hacker saber quais arquivos existem fora do diretorio root, atraves de tentativa e erro'\&.
.PP
\fBRetorna:\fP
.RS 4
0 caso nao haja erro e -1 em algum erro 
.RE
.PP

.SS "int get_file_chunk (struct \fBclienthandler_t\fP *h)"
.PP
Pega um pedaco do arquivo e guarda no buffer dentro de 'h''\&. \fBRetorna:\fP
.RS 4
0 se pegar todo o pedaco do arquivo de uma vez, 1 se o arquivo terminou de ser lido e -1 em caso de erro'\&. 
.RE
.PP

.SS "int handler_init (struct \fBclienthandler_t\fP *h, intsck, char *rootdir)"
.PP
Inicializa o \fBclienthandler_t\fP 'h' e associa seus servicos ao cliente representado por 'clientsckt''\&. Nessa funcao utiliza-se alocacao dinamica de memoria para criar um novo \fBclienthandler_t\fP'\&. 
.PP
\fBRetorna:\fP
.RS 4
0 em caso de sucesso, -1 em caso de erro ao efetuar malloc()'\&. 
.RE
.PP
\fBObservação:\fP
.RS 4
Essa funcao supoe que o socket 'clientsckt' esta devidamente conectado ao cliente'\&. 
.RE
.PP

.SS "int keep_sending_msg (struct \fBclienthandler_t\fP *h)"
.PP
Continua enviando para h->client a mensagem apontada por h->output atraves de sockets nao-bloqueantes'\&. \fBRetorna:\fP
.RS 4
O numero de caracteres enviados em caso de sucesso'\&. Se houver algum erro fatal, retorna -1'\&. Se o socket for bloquear, retorna -2'\&. 
.RE
.PP

.SS "int parse_request (struct \fBclienthandler_t\fP *h)"
.PP
Separa as partes uteis da request HTTP enviada pelo usuario'\&. \fBFuturas Atividades\fP
.RS 4
Por enquanto so mexemos com filename'\&. Implementar metodo e versao 
.RE
.PP
\fBRetorna:\fP
.RS 4
0 se tudo der certo, -1 caso a request contenha algum metodo nao-implementado'\&. 
.RE
.PP

.SS "int receive_message (struct \fBclienthandler_t\fP *h)"
.PP
Recebe a mensagem atraves de recv() de uma maneira nao-bloqueante'\&. \fBRetorna:\fP
.RS 4
0 caso a mensagem esteja sendo recebida, -1 em caso de erro e 1 se a mensagem terminou de ser recebida'\&. 
.RE
.PP

.SS "int start_sending_file (struct \fBclienthandler_t\fP *h)"
.PP
Abre o arquivo em 'h' para ser enviado'\&. \fBRetorna:\fP
.RS 4
0 em sucesso, -1 em caso de erro'\&. 
.RE
.PP

.SS "int stop_sending_file (struct \fBclienthandler_t\fP *h)"
.PP
Fecha o arquivo aberto para o 'h''\&. \fBRetorna:\fP
.RS 4
0 em sucesso e -1 em caso de erro'\&. 
.RE
.PP

.SH "Variáveis"
.PP 
.SS "int \fBclient\fP"
.PP
Socket do cliente servido'\&. 
.SS "int \fBfileerrorsize\fP"
.PP
Se houver algum erro relacionado ao arquivo, sua mensagem estara aqui (no formato de pagina HTML) para ser enviada ao cliente'\&. Tamanho da pagina HTML de erro 
.SS "char \fBfilepath\fP[BUFFER_SIZE]"
.PP
Localizacao do arquivo que o cliente solicitou'\&. 
.SS "int \fBfilestatus\fP"
.PP
Indica se o arquivo existe ou qual erro esta associado a ele'\&. Seus valores sao os mesmos da especificacao HTTP (status codes)'\&. 
.SS "char \fBfilestatusmsg\fP[BUFFER_SIZE]"
.PP
Mensagem equivalente ao status do arquivo'\&. 
.SS "char \fBrequest\fP[BUFFER_SIZE *3]"
.PP
Toda a request HTTP solicitada pelo cliente'\&. 
.SS "int \fBrequest_size\fP"
.PP
Tamanho de caracteres que 'request' suporta'\&. 
.SS "int \fBsize_left\fP"
.PP
Quanto do arquivo (caso exista) ainda precisa ser enviado ao cliente'\&. 
.SS "int \fBsize_sent\fP"
.PP
Quanto do arquivo (caso exista) ja foi enviado ao cliente'\&. 
.SH "Autor"
.PP 
Gerado automaticamente por Doxygen para servw a partir de seu código-fonte'\&.
