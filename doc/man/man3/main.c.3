.TH "src/main.c" 3 "Quarta, 25 de Janeiro de 2012" "servw" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/main.c \- 
.PP
A logica e funcao principal do programa'\&.  

.SH SYNOPSIS
.br
.PP
\fC#include <stdio\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <errno\&.h>\fP
.br
\fC#include <unistd\&.h>\fP
.br
\fC#include <fcntl\&.h>\fP
.br
\fC#include <netdb\&.h>\fP
.br
\fC#include <sys/stat\&.h>\fP
.br
\fC#include <limits\&.h>\fP
.br
\fC#include 'client\&.h'\fP
.br
\fC#include 'server\&.h'\fP
.br
\fC#include 'http\&.h'\fP
.br
\fC#include 'verbose_macro\&.h'\fP
.br

.SS "Definições e Macros"

.in +1c
.ti -1c
.RI "#define \fBMAX_CLIENTS\fP   10"
.br
.ti -1c
.RI "#define \fBBUFFER_SIZE\fP   256"
.br
.in -1c
.SS "Funções"

.in +1c
.ti -1c
.RI "int \fBhandle_args\fP (int argc, char *argv[])"
.br
.RI "\fILida com os argumentos passados pela linha de comando: port 'port number' e 'root directory''\&. \fP"
.ti -1c
.RI "int \fBbigger\fP (int a, int b)"
.br
.RI "\fIRetorna o maior numbero, 'a' ou 'b''\&. \fP"
.ti -1c
.RI "int \fBappend\fP (char *dest, char *orig, size_t size)"
.br
.RI "\fIAdiciona 'orig' a string 'dest' a partir do final, respeitando o limite de 'size''\&. \fP"
.ti -1c
.RI "int \fBfind_crlf\fP (char *where)"
.br
.ti -1c
.RI "int \fBget_http_status_msg\fP (int status, char *buff, size_t buffsize)"
.br
.ti -1c
.RI "void \fBdaemonize\fP (FILE *logfile, char *logname, FILE *errfile, char *errlogname)"
.br
.RI "\fICria um daemon atraves de fork(), 'matando' o processo pai e atribuindo stdout para 'logfile' e stderr para 'errfile''\&. \fP"
.ti -1c
.RI "int \fBmain\fP (int argc, char *argv[])"
.br
.in -1c
.SH "Descrição Detalhada"
.PP 
A logica e funcao principal do programa'\&. 


.SH "Funções"
.PP 
.SS "int append (char *dest, char *orig, size_tsize)"
.PP
Adiciona 'orig' a string 'dest' a partir do final, respeitando o limite de 'size''\&. \fBObservação:\fP
.RS 4
'size' e o tamanho TOTAL de 'dest' - nao pode ser o tamanho restante! 
.RE
.PP

.SS "void daemonize (FILE *logfile, char *logname, FILE *errfile, char *errlogname)"
.PP
Cria um daemon atraves de fork(), 'matando' o processo pai e atribuindo stdout para 'logfile' e stderr para 'errfile''\&. Caso haja um erro, essa funcao interrompe a execucao do programa e exibe a mensagem de erro em stderr'\&. Isso porque ela depende do perror() especifico de cada funcao chamada'\&. 
.SS "int main (intargc, char *argv[])"\fBFuturas Atividades\fP
.RS 4
.RE
.PP
\fBProblema\fP
.RS 4
.RE
.PP
\fBAviso:\fP
.RS 4
Caso o cliente conecte mas tenha um 'lag', o FD_ISSET do readfds nao vai dar'\&. Porem, se o cliente terminar de mandar a mensagem, vai acontecer a mesma coisa'\&. Como diferenciar o fato de que o cliente pode estar numa conexao lenta com o fato de que o cliente pode ter terminado de enviar?
.RE
.PP

.SH "Autor"
.PP 
Gerado automaticamente por Doxygen para servw a partir de seu código-fonte'\&.
